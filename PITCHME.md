---

# The Value of Values

- https://www.youtube.com/watch?v=-6BsiVyC1kM
- clj-nakano #2 2017/12/12
- 株式会社シグニファイア代表 中村研二 (github: k2n, twitter: @k2nakamura)

---

## 発表者について

- 93-00年 野村総合研究所、00-16年 米国スタートアップ数社で勤務
- 15年、200億円規模の米国証券バックオフィスシステムにClojureを適用
    - compojure-api, core.async, aleph, manifold, gloss, mysql, mongo db, docker, AWS
- 16年、Clojure+Docker+Micro Services+AWSでビスポーク開発を提供する株式会社シグニファイアを設立
- 16年、たばこ卸売業向けEコマースとたばこ税申告システム
    - AWS Lambda, Incanter, compojure-api, clara-rules, reagent, postgresql, docker, rancher, AWS
- 17年、グローバル法律事務所紹介ネットワークシステムでLegalWeek Innovation Awardsを受賞
    - reagent, re-frame, compojure-api, elastic search, postgresql, docker, rancher, AWS

---

## Information

- 今日話すのは"Value of Values" 「値の価値」について。
- まず、参加している皆さんに挙手をしていただくことから始めたい。この中でIT関連の業界で働いている人は？（大多数が挙手）
- ITが表しているものは？「情報技術」
- それではキーワードの定義から進めていきたい。
- 「技術」の方はわかりやすいので、「情報」について話したい。
- まずは言葉の定義から。もう皆さん私のスライドの構成を知っていますよね？発表をするとなったら、まずひとつの単語を選び、辞書を引いて、そこから展開していきます。
- 「情報」という言葉は、"Inform"という動詞から派生している。
- 「事実を通して知識を伝える」ことで「自分や他人の頭のなかに形を与える」。つまり事実を他人に伝える、ということ。
- ここでこの発表のキーワードとなるのが"facts"「事実」である。
- これから"facts"により精緻な定義を与えていくことになる。
- "Information"「情報」とは、情報を伝えるための事実の集積である。従来は情報を伝えるのに他の手段もあったが、現在ではこれが唯一の手段である。

---

## What is a Fact?

- それでは「事実」とは何か？
- 「事実」とは情報を格納するための「場所」である。
- あらゆる情報のために場所が用意されている。
- 事実には全て、情報を取得したり、場合によっては設定のための操作がついている。設定が直接操作できない場合は、別の方法で間接的に操作する場合もある。
- 操作が事実の変化を操作するための単一点である。
- 事実についてやりとりをする場合、場所の情報を使ってやりとりする。
- ...これでいい？ 変に思う人は手を挙げて。これは正しくない！全く間違っている。

---

## Place

- また辞書の定義に戻ると、「空間における特定の部分」
- "Space"「空間」は重要なコンセプトなので、後ほど深く掘り下げる。
- 特に、「場所」というのは空間の中で境界が定められている。
- 我々は日常のプログラミングの中で、「場所」の良い例を知っているはずだ。メモリ、ディスクセクタなども「場所」である。
- メモリやディスクセクタには番地が割り当てられており、我々はその場所にいって、内容を別のものに置き換えることができる。
- 我々にとって、「場所」という概念は非常に親しみ深いものである。

---

## 'Information' Systems?

- 我々は、メモリやディスクセクタの場所を使って「情報」システムを構築しているのか否かについて考えるのは非常に重要である。
- 我々はメモリを使うとき、普通オブジェクトを経由して用いる。ミュータブルオブジェクトは「場所」を抽象化したものにほかならない。
- 前に述べたように、オブジェクトはメソッドを持っている。オブジェクトがシステムを構築する際の中核的な要素となっている。
- 永続性の面でも同様である。テーブル、ドキュメント、レコード、どれも「場所」についての概念であり、更新することができる。指定された場所に行き、新しい値に置き換える操作をしている。
- これらの概念がシステムを支えている要素となっており、場所を隠そうとはしていない。

---

## PLOP

- このプログラミングモデルに対して、Place Oriented Programmingと命名した。
- もしあなたが情報を更新していれば、それはPLOPである。
- 我々がPLOPをするのには、理由がある。
- コンピュータの黎明期には、PLOPをせざるを得なかった。Guy Steeleが4KBメモリしか持たないコンピュータ上でシステムを構築したエピソードを語ってくれた。メモリの隅から隅まで番地が分かっており、2000番台はジャンプテーブル、この領域はデータ、この領域はコード、というようにメモリの内容全てを頭にいれる事ができた。ときには一つの番地を複数の目的に使いわけることもあった。充分な容量がなかったから、そうせざるを得なかったのだ。
- コンピュータメモリも、ディスクも非常に小さく、全てが非常に高価だった。だから、場所を意識して操作する方法を採用せざるを得なかったのだ。ここで鍵となるのは、この考え方は「かつては」合理的だった、ということである。この制約は、私がプログラマーとして働いていた間に、過去のものとなっていった。
- メモリもディスクの容量も何百万倍にもなった。我々の生活の中で、メモリとディスク以外でこれほど早いペースで変化したものなどあっただろうか？クルマが100万倍大きくなったと想像してみれば、これだけの規模で変化したものなどないことがわかるだろう。そのとき、同じルールが適用できるだろうか？それだけの変化で特徴が変わらないものなどあるだろうか？ほとんどありえない。
- しかし我々は物事がもっともっと小さかったときに下した決断を未だに引きずって、前進している。
- なぜPLOPの考え方が未だに支配しているのか。鍵となる問題がここにある。

---

## Memory and Records

- PLOPの話をする際、メモリとレコードについての話になることが多い。
- この2つの単語は、コンピュータが生まれる前から使われているものである。
- 我々はこの２つの単語をのっとった。メモリはRAMチップの中の番地、レコードはデータベーステーブルのスロットを意味するものとして使うようになった。
- のっとっただけではなく、おおまかな意味はまだ類似している。RAMのメモリと、頭の中の記憶は似ている概念である。
- 問題は、我々はこの例えをあまりに長く使い続けたために、思い込みになってしまっていることである。
- だが、我々は記憶についての事実に立ち戻らなければならない。
- 記憶についての事実は、記憶はオープンシステムだということである。もし友達が新しいEメールアドレスに変えたら、自分の頭の中の友達のレコードを探して、Eメールアドレスのセルを探して、古いアドレスを保持しているニューロンを新しいアドレスに置き換えるなんてことをするだろうか？脳はそういうふうには動かない、これはコンピュータメモリの動作である。記憶は本質的にオープンシステムであり、連想的なシステムである。アドレスベースシステムではない。
- レコードの記録についても同様である。コンピュータが生まれる前から我々はレコードを記録してきた。石板に文字を刻んだり、パピルスに書いたり。新しい情報を記録するときはどうしていた？大理石の表面を平らに削り直して、刻みなおしたりはしなかったし、パピルスをほぐして編み直したりもしなかった。コンピュータより前から、会計システムはあるが、そこでは消しゴムなど使われていなかった。複式帳簿であり、台帳である。修正仕訳を入れることで間違いを直し、消しゴムを使うことは決してない。

---

## Value

- それでは「値」について語ろう。これも定義する必要のある言葉である。また辞書に戻ろう。非常に興味深い定義がなされている。
- 第一の定義は、「相対的な価値」である。「相対的な」というのは値にとって非常に重要な観点となる。
- 第二の定義は、コンピュータプログラミングにも馴染み深いもので、例えば「42」という値である。規模を表したり、番号であったり、何かの量を表すものである。この定義が最も広く採用されているものである。
- しかし、より広義な「値」の定義は、意味について、比較可能性について、そして相対的価値についてである。これは「値」のより大きな意味である。何かを測定する際、何か他のものと比較して測定するしかない。絶対的な測定というものは存在しない。だから、比較という部分が重要になってくる。

---

## Is a String Value? 

- 次の質問は、「String（文字型）は値か否か」である。そうだと思う人は何人いますか？
- 手を挙げてもらう質問をするのを楽しみにしているんだ。全然手を挙げない人がかならずいるから。じゃあ、Stringは値じゃないと思う人は？
- では、「条件次第」と思う人は？
- いつだって「条件次第」の選択肢を待つべきだろ？これが最良の答えだから。この選択肢が出てくるまで待っていなきゃ。
- では、何次第なんだろうか？
- イミュータブル（不変）か否かで決まる。イミュータブルなら値だし、ミュータブルなら値じゃない。
- ミュータブルな文字型を持つプログラミング言語を使ったことのある人は？その言語に戻りたい人は？
- いないよね？そんな言語は好きじゃない。
- 文字列は何かを測るものではない。規模や量を表すものではないので、値のその定義にはあてはまらない。
- イミュータブルな文字型は比較可能なものだ。比較可能ということが論理を記述したり意思決定を可能にしている。
- 「これは昨日と同じか」「これは以前より多いか少ないか」「このラベルが物事を自分の解釈どおり正しく指し示しているか」など、情報を用いて我々が行っている全ては比較可能性にもとづいて行われている。
- 比較可能性と等値性テストが基盤としてあり、そこから値の他の定義が成り立っている。
- だから我々はミュータブルな文字型を持つプログラミング言語をまた使いたいとは決して思わないのだ。

---

## Programming Values

- 今まで辞書の定義から値について話してきたが、特にプログラミングの観点から述べてきた。細かな点は色々とあるのだが、この講演は30分しかないので、２つの点だけ触れることにする。
- 値はイミュータブルである。
- 値は意味論の観点から透過的である。
- 値の目的は自分自身を曝すことで、比較と等値テストをしてもらえることにある。
- 値の目的は何かをカプセル化してメソッドを提供して、何かをさせることではない。
- 値は、「私を何かと比較してくれ。私は自分の正確な意味や意義を伝えるから」と言っているのである。値は外側のラベルに直接書いてある。

---

## Value Propositions

- この講演を通じて、値の価値について提案しているのである。何が値を価値あるものにしているのか。
- もともとこの講演は1時間の枠で行っていたので、この点については少し早送りで話します。
- 値の特徴は色々とある。
- 初めに、値は共有することができる。もしイミュータブルな値を持っていて、それを誰か他の人に渡したとして、心配する必要はないか？ない！
- 渡された人は心配する必要があるか？ない！だから値は安全に共有することができる、これは非常に価値のあることだ。
- 値は再現可能な結果の生成をサポートする。値についての関数を定義したとき、同じ値を渡して関数を呼ぶたびに同じ答えが得られるか？得られる！
- もしメモリなどの場所についての関数を定義したとして、その関数を呼び出すたびに同じ答えが得られるか。No！その場所に何が格納されているか次第だ。
- 再現可能な結果は非常に重要だ。これによって我々はテストを実行した際に安定的に同じ結果を得ることができるからだ。
- 今日でも多くの人々が場所に対してテストを実行している。テストの結果はなんの意味もなさない。テストの品質は、あなたが場所を、同じ状態に、同じ値に戻せるかどうかにかかってくる。
- もう一つの非常に重大な値の様相は、でっち上げるのが簡単だ、ということである。
- どのプログラミング言語でも、値を１から作り上げるのは簡単にできる。
- 文字列を作るのも、文字列リストを作るのも、数字のリストを作るのも、数字のリストのリストも、数字のリストのマップも、簡単に作ることができる。
- あなたが定義したかっこいいインターフェースのインスタンスを、別の言語で作ることができるか？できない！でっち上げるのは簡単ではない。
- プログラムを作るプログラムを書くのは簡単じゃないし、テストを書くプログラムを書くのも簡単じゃない。もしプログラムが値を基にできているのでなければ。
- 値はでっち上げるのが簡単だという事実は重要である。
- 値は言語非依存である。既に述べたが、リスト、文字列、数字、マップ、これらはプログラミング言語に依存していない。これらの集合も同様である。
- 値は汎用的である。値という概念が汎用的である。日常の中で、プログラム言語やシステムにおける特異性がもたらすコストについて考えることはあまりない。
- 特異性が好きな人が多い。Javaで書く際、新しい概念一つ一つに新しいクラスを定義する。新しいことを考えるたびに新しいものを作っている。
- 結果として、爆発的に膨大なコードが必要になってしまう。オブジェクトは再利用をサポートするためのもののはずなのに、特に静的型付き言語の場合、正反対の結果を作り出してしまう。
- 再利用できる機会はほとんどない。なぜなら新しいものを常に作り続けているからだ。コードが多ければ、それだけバグも増える。
- 値についてもう一つ面白い点は、値は、値の集合をとることができる。文字列や数字などの原子的な値について既に話したが、イミュータブルな値のリストもまたイミュータブルである。値を組み合わせてできた大きなものもまた値なのである。
- 「文字列はもちろんイミュータブルだ」といいつつ、そのコレクションがイミュータブルになっていない言語など、理解すらできない。
- もうミュータブルな文字列を持つプログラミング言語を使いたい人などいない。ならなぜ、ミュータブルなコレクションでプログラムしたいのか？すべきではない！
- ミュータブルなコレクションを使ったプログラムを避けることで、非常に重要な恩恵を受けることができる。例えば、オブジェクトの場合、もしあなたがオブジェクトを持っていて、それを共有したいとしたら、何をするか？オブジェクトを定義し、インターフェースを見つけて、といったことはもちろんだが、その後は？もし並列実行環境だったら何をしなければならない？何らかのロッキングポリシーが必要になる。非常に難しい。実際のところ殆どの言語はロックを適切に定義するための仕組みを提供していない。もしロックを上手く定義できたとして、まだ問題はある。どうやってオブジェクトをコピーするのか、クローン時の振る舞いはどうするのか、これらの考慮を定義した全てのクラスについて行わなければならない。それをこなした上で、今度はオブジェクトの集合について考えなければならない。組み合わされたオブジェクトのロックポリシーは自動的に得られるのか？そんなことはない！今まで個別のオブジェクトに定義していたことは全て無駄になり、また一から始めなければならない。ロックポリシーを持つオブジェクトを組み合わせて作った複合オブジェクトに対して、個別に定義したロックポリシーが役に立たない。クローンポリシーについても、その他についても同様である。
- 値の集合は値であるから、値の利点は全て集合にも適用される。
- 値から得られる利点は他にもある。値は運搬が容易だ。もし自分が有用だと思う情報を持っていたら、他の人にその情報を送ることができて、送ったものが自分が見たのと同じ形で相手側にも見えるという確証が得られる。
- もし何か自分が興味深いと思うものを見つけて、その情報を保持している場所の情報を相手に送ったとしたら、一体何を伝えたことになるだろう？何も伝えたことにならない！情報ではないことは確かだ、なぜなら、他の人がその場所を見に行ったときに、自分が見ていたのとは全く違う情報が保持されているかもしれないからだ。
- 逆もまたしかり、認識も同様である。もし自分が何かを認識する際、それが値であれば、時間をかけてそれを観察することができる。とくに、値のセットや、複合的な値の場合はとくに有用である。
- もし場所ベースの情報を認識しなければならないとすれば、どうすればいい？いろいろな場所を調べなければならない。それらを調べている間、時間の流れを止めなければならない。そうしないと、ひとつのものをみて、頭の向きを変えて他のものを見ている間に情報が変わっているとしたら、一貫してるものをみることなどできるわけがないのだから。一貫した情報をもとに決断を下すことができない。
- 記憶についても同様である。プログラムをしている間に記憶しておきたいオブジェクトが出てきた場合、どうする？ 参照を保持しているだけでは不十分だ。クローンを作成しなければならない。じゃ、どうやってクローンをつくる？それはケース・バイ・ケースだ。
- 次に、プログラムが１つのプロセスや、サーバに収まりきらなくなってきたらどうする？値の長所はシステムレベルでも活きてくる。特に、値は最も優れたインターフェースである。ここに議論の余地があるとは思えない。もう我々は既に実践しているからだ。通信のときに送っているものは何か？まだCORBAやDCOMを使っている人はいる？いないでしょう？これらの技術は理由があって廃れてしまったのだ。今日では、我々はJSONやXMLを使って値を送っている。両者とも、値の表現形式である。これらを用いることで我々はインターフェースを構築できるし、両端で簡単に変換できる。
- 小規模システムにも当てはまるが、大規模システムで特に興味深い値の価値は、先程話した、認識する際には時間を止めなければいけないと言う点について、この問題は大規模システムにも生じるということだ。「リード・トランザクション」という言葉を聞いたことがある人はどれくらいいる？リード・トランザクションを好きな人は？いないよね？このコンセプトは全く直感的ではないし、物理法則に反している。現実世界では、我々はお互い情報を読み取っているだけで、何か情報を読み取るために全てを止める必要はない。値ベースのプログラミングをする際、特にストレージに格納されている値を用いる際、お互いの作業を調整する必要が減る。
- 別の利点として、データの格納場所の自由度が増す。小規模システムは値をやり取りするプロセス群で構成されている。そのシステムをより速い言語で書き直す、あるいは別のサーバで稼働させる、こういった要件が出たとき、オブジェクトや、今使っているプログラム言語固有のものを使っていると、実現するのは簡単ではない。例えば、Javaでインターフェースを書いていたとして、それをRubyで書き直すのは簡単なことだろうか？そんなことはない！大局的にみたとき、我々はそのようなことはせず、値を用いてコミュニケーションをしている。なのに、極小的な、プログラミング言語の中の世界になると、我々はベトベトした、スマートじゃない方法をとってしまう。そのベトベトさのせいで、物事を動かす自由度が制限されてしまうのだ。他のスレッドに移譲したり、他の言語で書き換えたり、他のサーバに引越したり、といったたぐいのことである。値を使えば、そのような問題は発生しない。これが私のいうところのロケーションの柔軟性である。

---

## Facts are Values

- それでは「情報技術と事実」に立ち戻ることとしよう。
- 「事実」についての事実は、「事実」は「値」である、ということである。
ｰ 事実は場所ではない。冒頭で示したスライドはウソである。聴衆の皆さんは、「しかし事実は変化するものではないのですか」と尋ねるかもしれない。「大統領だって、時が経てば変わるじゃないですか」と。それは大間違いである！事実が時間とともに変わることはない！事実は時間を取り込んでいるのである。どういう意味か？再度、辞書を引いてみよう。辞書は全てを知っている。「事実」の定義は、「過去に起こった何か」「過去から知られている何か」というラテン語から来ているのである。語源のラテン語は過去分詞である。ということは、事実は、過去に起こった何か、なのである。場所でもないし、我々が変えられるものでもない。「ビル・クリントンは大統領だった」という事実は、将来に渡って事実で有り続けるのだ。もちろん、新しい大統領は出てくる。だが、それは新しい事実である。あなたが新しいEメールアドレスをもらったときと同様である。

---

## Facts != Recent Facts

- 「事実」についてのもう一つの重要な事実は、最近の事実を考慮するだけでは不十分だ、ということである。
- もう一度、「情報」について立ち戻ろう。情報とは、知らせることである。だから人々は知識を伝えられる。しかし、知識は事実によって成り立っている。我々が物事を判断するとき、時間を比較したり、２つの異なる物事を比較する。異なる物事を組み合わせる。特に、起こったタイミングの異なる物事を比較する。自分が、現時点での世界の物事の値しか知らないと想像してみてほしい。あなたは良い意思決定ができると思いますか？ひどい決断しかできないはずだ。それにも関わらず、我々は直近の事実しか持たないシステムを作り続けている。我々が作っているのは情報を処理し、意思決定をサポートするシステムのはずだ。
- 要約すると、我々は事実を更新することはできない、ということである。更新できない理由は、我々は過去の事実を変更することはできないからである。事実とは、過去に関する記述なのだから。

---

## Information Systems

- それでは、冒頭に立ち戻ろう。情報を扱う、情報システムを構築するとは何を意味するのか？
- 根源的に、そのシステムは事実についてのものであるはずだ。事実を保持し、操作する仕組みのはずだ。
- そしてその事実をユーザに提示して手助けをするためのものだ。それを使ってユーザは意思決定をする。
- 我々が情報システムを構築する際、意思決定を支援するシステムを作っていると思っているはずだ。
- しかし、我々は事実指向のインフラストラクチャを使っていない。
- 時間軸を考える以前に、基礎となる部分を考えるだけでも、値指向のシステムを作らなければならないはずだ。
- しかし、プログラム言語が場所指向の構成要素を持つべきではない、といっているわけではない。もちろん必要だ。だが我々は場所指向と値指向を区別していない。
- どのプログラムにも２つの異なる構成要素がある。プログラムの一部は、機械のような動作が求められている。ドキュメントを読み込んだり、ものが入ってきたらコンベヤーベルトに乗っけたり、それを流して、ソートしたり分割して、それぞれを格納したり。どのプログラムにもプロセス指向の、機械のような要素がある。我々は小さな機械に類似したプログラム言語を使っている。
- 問題は、我々がその仕組を情報を含む全てに適用している、という点である。
- 情報は、小さな機械ではない。機械に例えられる要素は全くない。だからプロセス指向の構成要素とは分けて考えなければならないのだ。
- 特に、今日得た教訓として持って帰ってもらいたいのは、プログラミング言語の中で、場所指向の構成要素は、情報システムには全く使いみちがないということである。それらの構成要素は、コンピュータがどう動くかを表すものであって、あなたがソフトウェアで実現しようとしているものととは全く関係がない。もしあなたの書くソフトウェアが情報管理と意思決定支援を行おうとしているのであれば。
- この講演で特筆すべきことがあるとすれば、もうこの話を聞いてくださっている皆さんはおわかりかと思いますが、意思決定に必要なのは、継続的に現在と過去を比較することである。傾向を見極めたり、変化の度合いを見たり、起こった事実を蓄積したり、ほぼ常に、時間軸を必要とする。

--- 

## Programmer I.T.

- これが真実であると、どうやったら伝えられるだろうか？これは非常に簡単である。
- 我々はプログラマで、我々にはすべき仕事があるよね？何を作っている？具体的な成果物は何か？我々はソースコードを書いているよね？
- 我々はオペレーション的な仕事もしている。プログラムを走らせているよね。
- 我々はこれらについての情報を管理している。
- プログラマのための情報技術、という観点で見てみよう。我々自身のためのITシステムである。
- ソースコード管理システム。ファイルシステム上で直接更新している人いる？新しく編集した際、直接ディレクトリに格納している人？ここで手を挙げちゃダメだよ、しないよね！直接ファイルを書き換えちゃダメでしょ！
- タイムスタンプを持たないソースコード管理システムを使っている人いる？いないよね！もちろんない。時間情報なくして、何をしていたかなんて分かるわけないし、ソフトウェアビジネスを経営することなんてできないよね！過去の情報と時間情報は必要不可欠なものである。
- 今度はITのオペレーションの側面を見ていく。システムを稼働させているとき、何をしている？ログをとっている。システム内で起こったことを全て記録しているよね？情報を上書きするログシステムを使っている人いる？直近５秒間だけログを保持するシステムは？そんな人いないよね！行毎にタイムスタンプを付与しないログシステムを使っている人いる？そんなのあり得ないよね！もし過去の情報を保持せず、タイムスタンプがなければ、どうやってシステムがうまく動いているかわかる？どうやって意思決定ができる？できっこない！だからこんなことはしていないはずだ。

---

## Big Data

- 全てつながっている。
- ビッグデータとは何か？ビジネスサイドがプログラマに向かって、「お前が持っているデータベースのほうが、お前が我々にくれたデータベースより良さそうにみえるから、それをくれ。だってお前がくれたデータベースは、我々がくれといった時点までのデータしかないから。お前のデータベースには現時点までの全ての情報が含まれている。そのデータベースをマイニングして、ビジネスの意思決定に有用な情報を探すんだ」と言っているケースが一定割合あると思っている。
- ログは全ての情報を持ち、タイムスタンプもついている。だが残念なことに、この分野において我々プログラマは受け身な態度だ。
- ログのマイニング？ 我々は情報を表示するもっといいやり方を知っている。データを活用しやすいように格納する方法だって知っている。ログはそういう操作に適していない。ログはMapReduceに向いていないし、ログにはプログラムのオペレーションそのものに関する情報が含まれているので、ノイズが多すぎる。
- ログにはビジネス価値のある情報が含まれているのに、それを格納するデータベースをまだ構築していない。
- だが、これらは我々のせいである。

---

## Space Age

- 我々は、私が言うところの「宇宙時代」に入りつつある。
- ここの辞書の定義をもう一つ。「宇宙」とは、全ての物事、全てのできことが含まれている、無制限の広がりである。
- この定義で非常に興味深いのは、どれだけ古い定義に遡ってみても、空間と時間を含んでいる点である。どちらかにしか適用されていない、ということは決してない。
- 空間と時間は常に関連付けられていて、そこには物理法則がある。
- もし、オブジェクトを割り当てる"new"を四六時中呼び続けても失敗しない環境だとすると、それは場所の中で動いているのではなくて、「宇宙」の中で動いているということになる。端っこをみることはできず、区切られてもいない。新しいオブジェクトが必要なら、必ず得ることができる。
- もし、S3がいっぱいになることがないのなら、それはクラウドではない、「宇宙」だ。もし必ずS3がファイルを受け入れてくれるなら、境界を意識する必要がない。

---

## New Facts, New Space

- 情報システムは、違ったアプローチをとるべきである。
- 新しい事実は、新しい場所を必要とする。
- これがPLOPの終焉である。
- 我々は長い間これを実現するための機能は持っていた。
- もしこれを行うことができる状態になったのなら、他のやり方などする必要がない。
- ディスクが５MBしかないから、本当はログをとっておきたいけどできない、など言ったことがある人はいる？そう、昔は５MBのディスクに何千ドルも払っていた。
- もうそんな時代じゃない。今の我々はこれを実行できる環境を持っている。
- このパラダイム・シフトが起こると、いろいろおもしろいことが起こる。その一つは、今メモリ上で行われているガーベージ・コレクションが、ストレージ層に対して行われるようになる。ディスク上に不要になった情報が残るようになるから。でも大丈夫。対処の方法をそのうち確立していくはずだ。

---

## Summary

- 残念なことに、我々はPLOPを使い続けるだろう。もう合理性はなくなっているにも関わらず、だ。
ｰ 更に残念なことに、我々は今日でもまっさらな新しいプログラム言語やデータベースを、PLOPの考え方のもとに作り続けている。
- PLOPは10年前(2002年)から合理性をなくしている、少なくとも間違いなく５年前(2007年）からは。
- 我々が私がここまでに述べてきた長所を全て逃してきている。
- どの長所一つとっても、私は何時間でもその良さを述べることができる。値には、非常に数多くの長所がある。
- 我々は、自分たちのために使っている情報システムで、それを既に証明している。
- 我々はログを上書きしないし、ソースコードも上書きしない。我々は既に「宇宙時代」の中にいる。我々が支えるビジネスも、「宇宙時代」に移行しなければならないのだ。
- ビッグデータ、ログマイニング、全てを追跡し、全てを記録する昨今の圧力が、ビジネスアプリケーションも「宇宙時代」に移行する手助けとなり、ここには大きな需要があるはずだ。ビジネスはその価値に気づいている。需要があることははっきりしている。
- それを実践するのに必要なリソースは既にある。情報指向のアプローチをとって、プログラムを構築する心構えこそが今求められているものなのである。

